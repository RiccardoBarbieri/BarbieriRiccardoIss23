<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>

<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
<link rel="stylesheet" href="../../_static/template.css">
<link rel="stylesheet" href="../../_static/mine.css">
   
<head>
<title>BarbieriRiccardoAppl1HTTPSprint3</title>
</head>
    
<body>

<div id="top">
    <h1>LABORATORIO DI INGEGNERIA DEI SISTEMI SOFTWARE <font size="5"></font> </h1>
</div>  

<div class="body"> 

<h2>Introduction</h2>
<div class="remark">
In questo documento si tratter&agrave; l'analisi e lo sviluppo dello sprint 3 dell'applicazione HTTP BoundaryWalk.<br>

Dallo sprint 2 si &egrave; ottenuta la seguente architettura:<br>
<img src="https://iss.riccardob.dev/_images/Appl1HTTPSprint2Final.png" width="auto" height="200em"></img>
<br>
La classe <a href="https://iss.riccardob.dev/code#Appl1Core"><code class="prettyprint">unibo.appl1.http.Appl1Core</code></a> realizza la logica applicativa ed &egrave; resa osservabile al fine di accettare <code class="prettyprint">Observer</code> sui quali si basa la strategia di testing.

</div>

<h2>Requirements</h2>

<div class="remark">

<div class="req">
Scrivere un programma Java che possa inviare al VirtualRobot23 (attraverso una Console remota):
<ul>
    <li>un comando start per attivare il VirtualRobot in modo che percorra il bordo perimetrale della stanza rappresentata ne <a href="https://iss.riccardob.dev/VirtualRobot23.html#la-scena-di-wenv">La scena WEnv</a></li>
    <li>un comando stop per bloccare l'azione del VirtualRobot</li>
    <li>un comando di resume per riattivare l'azione del VirtualRobot</li>
</ul>
</div> 

<bc>Goals dello sprint 3:</bc><br>
<ol>
    <li>Affrontare il progetto e la realizzazione della CmdConsole remota.</li>
    <li>Affrontare il progetto e la realizzazione di un sistema distribuito.</li>
</ol>

</div>

<h2>Requirement analysis</h2>

<div class="remark">
    
<ul>
    <li><bc>KEYPOINT-Req1</bc> Il sistema deve essere in grado di operare in maniera distribuita</li>
    <li><bc>KEYPOINT-Req2</bc> I componenti del sistema saranno attori comunicanti tramite scambio di messaggi</li>    
    <li><bc>KEYPOINT-Req3</bc> Gli attori dovranno essere indipendenti dal protocollo <b>P</b> utilizzato per la comunicazione</li>
    
</ul>

</div>

<h2>Problem analysis</h2>

<div class="remark">
In questo sprint si rimarca l'utilizzo del <i>inversione delle dipendenze</i>, che consiste nell'assicurare che componenti di alto livello siano indipendenti dall'implementazione di componenti di basso livello, ad esempio:<br><br>

<bc>KEYPOINT-AP1</bc><br>
La <code class="prettyprint">CmdConsole</code>, in qualit&agrave; di strumento di input, deve essere indipendente da dettagli applicativi, in quanto l'applicazione potrebbe ricevere messaggi da dispositivi diversi.<br><br>

<bc>KEYPOINT-AP2</bc>
La <code class="prettyprint">CmdConsole</code> comunicher&agrave; con <code class="prettyprint">Appl1</code> tramite messaggi di tipo <b><i>dispatch</i></b>, ovvero comunicazioni con semantica <i>fire-and-forget</i> che non si aspettano una risposta.<br><br>

<bc>KEYPOINT-AP3</bc>
Il core dell'applicazione <code class="prettyprint">Appl1Core</code> invier&agrave; messaggi al <i>VirtualRobot</i> tramite <b><i>request</i></b> HTTP (sincroni).<br><br>

Questi scambi di messaggi richiedono un supporto di comunicazione che si concretizza in:
<ul>
    <li><code class="prettyprint">ServerFactory</code> permette di creare un server in grado di ricevere messaggi, usando un dato protocollo, da un client che implementa l'interfaccia <code class="prettyprint">Interaction</code></li>
    <li><code class="prettyprint">ActorNaiveCaller</code> permette l'invio di messaggi usando un dato protocollo</li>
</ul><br>

Con questa nuova infrastruttura di comunicazione, si classificano i componenti <code class="prettyprint">CmdConsole</code> e <code class="prettyprint">Appl1</code> come <i><b>attori</b></i>, ovvero entit&agrave; computazionali prive di memoria comune che interagiscono tramite scambio di messaggi.

In questa immagine si rappresenta una architettura intermedia che denota la struttura di comunicazione tra gli attori:<br>
<img height="150em" src="https://iss.riccardob.dev/_images/Appl1ArchSprint3Interaction.png" alt="Appl1ArchSprint3Interaction"><br>

<h3>Architettura logica</h3>
<img height="250em" src="https://iss.riccardob.dev/_images/Appl1FinalArchitecture.png" alt="Appl1FinalArchitecture"><br>
Nella figura &egrave; rappresentata l'architettura logica finale del progetto Appl1.<br><br>

Si denota il componente <a href="https://iss.riccardob.dev/code#Appl1MsgHandler"><code class="prettyprint">Appl1MsgHandler</code></a> che riceve dal server le richieste inviate dalla console tramite il metodo <code class="prettyprint">elaborate</code> e le inoltra correttamente al core dell'applicazione, questo componente si occupa anche di costruire e inviare le risposte per richieste che li prevedono.

</div>

<h2>Test plans</h2> 


<h2>Project</h2> 


<h2>Testing</h2> 
 

<h2>Deployment</h2> 

 
<h2>Maintenance</h2> 
 
<!-- USEFUL
<table style="width:100%" border="1">
<tr>
<td style="width:50%">
</td>
<td></td>
</tr>
</table>
-->
	      	
<br/><br/> 	
</div>  

<div style="background-color:rgba(86, 56, 253, 0.9); width:60%;text-align:left;color:white">
By Riccardo Barbieri email: riccardo.barbieri11@studio.unibo.it, 
<img src="../../_images/fototessera.jpg" alt="mbot" width="15%" height="15%">
GIT repo: https://github.com/RiccardBarbieri/BarbieriRiccardoIss23 
</div> 
</body>
</html>
